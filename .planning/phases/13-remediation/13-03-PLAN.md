---
phase: 13-remediation
plan: 03
type: execute
wave: 3
depends_on:
  - 13-02
files_modified:
  - enterprise-work-assistant/src/AssistantDashboard/hooks/useCardData.ts
  - enterprise-work-assistant/schemas/output-schema.json
  - enterprise-work-assistant/src/AssistantDashboard/ControlManifest.Input.xml
  - enterprise-work-assistant/src/AssistantDashboard/index.ts
  - enterprise-work-assistant/src/AssistantDashboard/components/App.tsx
  - enterprise-work-assistant/src/AssistantDashboard/components/CommandBar.tsx
  - enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx
  - enterprise-work-assistant/src/AssistantDashboard/components/BriefingCard.tsx
  - enterprise-work-assistant/docs/agent-flows.md
  - .planning/PROJECT.md
  - enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx
  - enterprise-work-assistant/src/test/index.test.ts
  - enterprise-work-assistant/src/test/jest.config.ts
autonomous: true
requirements:
  - FIX-02

must_haves:
  truths:
    - "useCardData reads card_status from discrete Dataverse column so NUDGE status reaches the PCF"
    - "CommandBar receives orchestratorResponse and isProcessing input properties and displays responses"
    - "ErrorBoundary wraps App content area and catches render crashes with recovery UI"
    - "Flow error scopes include notification actions and error log table is defined"
    - "ConfidenceCalibration has test coverage for all 4 tabs, empty states, and division safety"
    - "index.ts has test coverage for PCF lifecycle methods"
  artifacts:
    - path: "enterprise-work-assistant/src/AssistantDashboard/hooks/useCardData.ts"
      provides: "card_status from discrete column via getFormattedValue"
      contains: "getFormattedValue"
    - path: "enterprise-work-assistant/src/AssistantDashboard/ControlManifest.Input.xml"
      provides: "orchestratorResponse and isProcessing input properties"
      contains: "orchestratorResponse"
    - path: "enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx"
      provides: "React error boundary class component"
      contains: "componentDidCatch"
    - path: "enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx"
      provides: "ConfidenceCalibration test coverage"
      contains: "describe"
    - path: "enterprise-work-assistant/src/test/index.test.ts"
      provides: "PCF lifecycle test coverage"
      contains: "updateView"
  key_links:
    - from: "useCardData.ts"
      to: "Dataverse cr_cardstatus column"
      via: "getFormattedValue reads discrete column"
      pattern: "getFormattedValue.*card_status"
    - from: "ControlManifest.Input.xml"
      to: "index.ts"
      via: "orchestratorResponse property binding"
      pattern: "orchestratorResponse"
    - from: "ErrorBoundary.tsx"
      to: "App.tsx"
      via: "ErrorBoundary wraps children"
      pattern: "ErrorBoundary"
---

<objective>
Fix frontend component issues that depend on Wave 2 flow specifications, add monitoring/error infrastructure, and create missing test coverage.

Purpose: These fixes complete the end-to-end data flow for NUDGE status (F-01 depends on R-07), the CommandBar response channel (F-02 depends on R-06), crash recovery (F-03), monitoring (I-18), and test coverage gaps (F-04, F-05). After this wave, all 20 BLOCK issues from Phases 10-12 are resolved at the code/docs level.

Output: Fixed frontend components, new ErrorBoundary, monitoring infrastructure, and 2 new test files.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-remediation/13-01-SUMMARY.md
@.planning/phases/13-remediation/13-02-SUMMARY.md
@.planning/phases/12-integration-e2e-review/12-02-integration-review-verdict.md
@.planning/phases/11-frontend-pcf-review/11-02-frontend-review-verdict.md

Source files:
@enterprise-work-assistant/src/AssistantDashboard/hooks/useCardData.ts
@enterprise-work-assistant/src/AssistantDashboard/ControlManifest.Input.xml
@enterprise-work-assistant/src/AssistantDashboard/index.ts
@enterprise-work-assistant/src/AssistantDashboard/components/App.tsx
@enterprise-work-assistant/src/AssistantDashboard/components/CommandBar.tsx
@enterprise-work-assistant/src/AssistantDashboard/components/BriefingCard.tsx
@enterprise-work-assistant/src/AssistantDashboard/components/ConfidenceCalibration.tsx
@enterprise-work-assistant/src/AssistantDashboard/components/CardItem.tsx
@enterprise-work-assistant/docs/agent-flows.md
@enterprise-work-assistant/src/test/jest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix NUDGE ingestion, CommandBar response channel, and add ErrorBoundary</name>
  <files>
    enterprise-work-assistant/src/AssistantDashboard/hooks/useCardData.ts
    enterprise-work-assistant/schemas/output-schema.json
    enterprise-work-assistant/src/AssistantDashboard/ControlManifest.Input.xml
    enterprise-work-assistant/src/AssistantDashboard/index.ts
    enterprise-work-assistant/src/AssistantDashboard/components/App.tsx
    enterprise-work-assistant/src/AssistantDashboard/components/CommandBar.tsx
    enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx
  </files>
  <action>
    **F-01 / I-02: Fix card_status ingestion path for NUDGE**
    - In useCardData.ts, find where card_status is read from the parsed cr_fulljson JSON blob
    - Change to read card_status from the discrete Dataverse column instead, using the DataSet API's getFormattedValue or getValue method on the cr_cardstatus column
    - Logic: `const cardStatus = record.getFormattedValue("cr_cardstatus") || parsedJson.card_status || "READY"`
    - This ensures that when the Staleness Monitor flow (Wave 2, Flow 8) sets the discrete cr_cardstatus column to NUDGE, the PCF receives the updated value
    - The JSON blob's card_status remains as a fallback for initial agent-set values (READY, PROCESSING, etc.)
    - Also add "NUDGE" to the card_status enum in output-schema.json (alongside READY, PROCESSING, etc.) so the schema contract is complete

    **F-02 / I-12: Add CommandBar response channel**
    - In ControlManifest.Input.xml, add two new input properties:
      ```xml
      <property name="orchestratorResponse" display-name-key="Orchestrator Response" description-key="JSON response from command execution flow" of-type="SingleLine.Text" usage="input" />
      <property name="isProcessing" display-name-key="Is Processing" description-key="Whether a command is currently being processed" of-type="TwoOptions" usage="input" />
      ```
    - In index.ts updateView method, read the new properties:
      ```typescript
      const orchestratorResponse = context.parameters.orchestratorResponse?.raw || null;
      const isProcessing = context.parameters.isProcessing?.raw || false;
      ```
    - Pass these values through to App.tsx props and down to CommandBar
    - In CommandBar.tsx:
      - Accept orchestratorResponse (string | null) and isProcessing (boolean) props
      - Parse orchestratorResponse as JSON when non-null (format from Flow 7: {status, summary, actions_taken, error_message})
      - Display response below the command input: show "Processing..." when isProcessing=true, show summary text when response arrives, show error_message on failure
      - Clear response display when user starts typing a new command

    **F-03 / I-13: Create React ErrorBoundary**
    - Create new file: enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx
    - Implement as a React class component (React 16 compatible -- no hooks in error boundaries):
      ```typescript
      import * as React from "react";

      interface ErrorBoundaryState {
        hasError: boolean;
        error: Error | null;
      }

      export class ErrorBoundary extends React.Component<
        { children: React.ReactNode },
        ErrorBoundaryState
      > {
        constructor(props: { children: React.ReactNode }) {
          super(props);
          this.state = { hasError: false, error: null };
        }

        static getDerivedStateFromError(error: Error): ErrorBoundaryState {
          return { hasError: true, error };
        }

        componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
          console.error("AssistantDashboard error:", error, errorInfo);
        }

        render(): React.ReactNode {
          if (this.state.hasError) {
            return (
              <div style={{ padding: "20px", textAlign: "center" }}>
                <h3>Something went wrong</h3>
                <p>The dashboard encountered an error. Please refresh the page.</p>
                <button onClick={() => this.setState({ hasError: false, error: null })}>
                  Try Again
                </button>
              </div>
            );
          }
          return this.props.children;
        }
      }
      ```
    - In App.tsx, import ErrorBoundary and wrap the main content area (NOT the entire App, just the content that renders card data):
      ```typescript
      import { ErrorBoundary } from "./ErrorBoundary";
      // ... inside render:
      <ErrorBoundary>
        {/* existing content area with card gallery, card detail, etc. */}
      </ErrorBoundary>
      ```
    - This prevents a single malformed card record from crashing the entire dashboard

    **F-07: Resolve tech debt #13 (briefing schedule)**
    - In PROJECT.md, reclassify tech debt #13 from "deploy-blocking" to "deferred"
    - Add rationale: "Briefing schedule configuration requires a dedicated Dataverse table (BriefingSchedule) and UI flow that is beyond the v2.1 audit scope. The Daily Briefing flow (Flow 6) uses a fixed schedule configured in Power Automate recurrence trigger. User-configurable scheduling is deferred to a future milestone."
    - In BriefingCard.tsx, if there is any placeholder or stub code for schedule configuration, add a TODO comment: `// TODO: Schedule configuration deferred to post-v2.1 milestone`
  </action>
  <verify>
    <automated>grep -c "getFormattedValue" enterprise-work-assistant/src/AssistantDashboard/hooks/useCardData.ts | grep -q '[1-9]' && echo "PASS: discrete column read" || echo "FAIL"; grep -c "orchestratorResponse" enterprise-work-assistant/src/AssistantDashboard/ControlManifest.Input.xml | grep -q '[1-9]' && echo "PASS: manifest property" || echo "FAIL"; test -f enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx && echo "PASS: ErrorBoundary exists" || echo "FAIL"; grep -c "ErrorBoundary" enterprise-work-assistant/src/AssistantDashboard/components/App.tsx | grep -q '[1-9]' && echo "PASS: ErrorBoundary used" || echo "FAIL"; grep -c "componentDidCatch" enterprise-work-assistant/src/AssistantDashboard/components/ErrorBoundary.tsx | grep -q '[1-9]' && echo "PASS: error boundary class" || echo "FAIL"</automated>
  </verify>
  <done>
    - useCardData.ts reads card_status from discrete Dataverse column via getFormattedValue, with JSON blob as fallback
    - output-schema.json includes NUDGE in card_status enum
    - ControlManifest.Input.xml has orchestratorResponse and isProcessing input properties
    - index.ts passes new properties through to App
    - CommandBar.tsx displays orchestrator responses and processing state
    - ErrorBoundary.tsx exists as a React class component with getDerivedStateFromError and componentDidCatch
    - App.tsx wraps content area with ErrorBoundary
    - Tech debt #13 reclassified as deferred in PROJECT.md
  </done>
</task>

<task type="auto">
  <name>Task 2: Add monitoring infrastructure and create missing test coverage</name>
  <files>
    enterprise-work-assistant/docs/agent-flows.md
    enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx
    enterprise-work-assistant/src/test/index.test.ts
    enterprise-work-assistant/src/test/jest.config.ts
  </files>
  <action>
    **I-17: Document staleness refresh mechanism**
    - The PCF itself cannot implement a timer (no setInterval in PCF virtual controls)
    - Document the recommended approach in agent-flows.md (or a separate section):
      - Canvas App approach: Add a Timer control in the Canvas App with Duration=30000 (30 seconds). On Timer.OnTimerEnd, call `Refresh(AssistantCards)` to trigger the PCF's updateView with fresh DataSet data
      - Alternative: Add a "Refresh" button in the Canvas App toolbar that calls `Refresh(AssistantCards)` on click
    - Add a note to the deployment guide or agent-flows.md: "Canvas App Configuration: Add a Timer control (Duration: 30000, Repeat: true, AutoStart: true, Visible: false) with OnTimerEnd = Refresh(AssistantCards) for automatic card refresh every 30 seconds."
    - Note: This is a Canvas App configuration, not a PCF code change. The PCF automatically receives fresh data when the Canvas App refreshes the DataSet.

    **I-18: Add monitoring strategy to flow error scopes**
    - In agent-flows.md, add a new section "## Error Monitoring Strategy" that defines:
      1. **Error Log Table:** Define a Dataverse table `cr_errorlog` with columns:
         - cr_errorlogid (Primary Key, GUID)
         - cr_flowname (Text, 100) -- which flow failed
         - cr_errormessage (MultilineText) -- error details
         - cr_errorstep (Text, 200) -- which step failed
         - cr_occurredon (DateTime) -- when it happened
         - cr_severity (Choice: Info=100000000, Warning=100000001, Error=100000002)
         - cr_isresolved (Boolean, default false)
      2. **Error Scope Pattern:** For each flow's error Scope, add these actions:
         - Create record in cr_errorlog with flow name, error message from `result('StepName')?['error']?['message']`, step name, and utcNow()
         - Send email notification to admin (configurable, use environment variable `AdminNotificationEmail`)
      3. **Document this pattern** in each flow spec's error Scope description
    - Update provision-environment.ps1 would be ideal, but that file is owned by 13-01. Instead, add a NOTE in the monitoring section: "The cr_errorlog table must be added to provision-environment.ps1 for automated deployment."

    **F-04: Create ConfidenceCalibration test file**
    - Create new file: enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx
    - Test coverage requirements (324 lines of analytics logic):
      1. **Triage Distribution tab:** Test with mock cards having different triage_tier values, verify correct count and percentage calculations
      2. **Priority Breakdown tab:** Test with mock cards having different priority values, verify bar chart data is correct
      3. **Draft Quality tab:** Test with cards having different outcomes (SENT_AS_IS, SENT_EDITED), verify draftStats calculations
      4. **Response Time tab:** Test with cards having different response hours, verify average computation
      5. **Empty state:** Test with empty card array, verify "No data" or 0 values display without errors
      6. **Division safety:** Test that division by zero is handled (0 total cards, 0 sent cards) -- no NaN or Infinity in rendered output
      7. **Edge cases:** Single card, all same tier, negative/null values in confidence_score
    - Use the same testing patterns as existing test files (check existing tests in src/test/ for import patterns, mock setup, and assertion style)
    - Import ConfidenceCalibration component and render with @testing-library/react

    **F-05: Create index.ts PCF lifecycle test file**
    - Create new file: enterprise-work-assistant/src/test/index.test.ts
    - Test coverage requirements (156 lines of PCF lifecycle):
      1. **init():** Test that init creates the React container element
      2. **updateView():** Test that updateView renders the React component with correct props extracted from context
      3. **updateView() with DataSet:** Test that dataset records are passed through to the component
      4. **getOutputs():** Test that getOutputs returns the expected output property structure (commandText, selectedCardId, etc.)
      5. **destroy():** Test that destroy unmounts the React component and cleans up
      6. **Output property reset:** Test the pattern where output properties are set and then reset to empty on next updateView
    - Mock the ComponentFramework.Context and DataSet interfaces
    - In jest.config.ts, REMOVE the coverage exclusion for index.ts (find the exclude pattern and remove it so index.ts is included in coverage reporting)
  </action>
  <verify>
    <automated>test -f enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx && echo "PASS: ConfidenceCalibration tests exist" || echo "FAIL"; test -f enterprise-work-assistant/src/test/index.test.ts && echo "PASS: index tests exist" || echo "FAIL"; grep -c "describe\|it(" enterprise-work-assistant/src/test/ConfidenceCalibration.test.tsx 2>/dev/null | grep -q '[5-9]\|[1-9][0-9]' && echo "PASS: multiple test cases" || echo "FAIL"; grep -c "describe\|it(" enterprise-work-assistant/src/test/index.test.ts 2>/dev/null | grep -q '[3-9]\|[1-9][0-9]' && echo "PASS: lifecycle tests" || echo "FAIL"; grep -c "cr_errorlog\|Error Monitoring" enterprise-work-assistant/docs/agent-flows.md | grep -q '[2-9]' && echo "PASS: monitoring strategy" || echo "FAIL"</automated>
  </verify>
  <done>
    - I-17 staleness refresh mechanism documented (Canvas App Timer configuration)
    - I-18 monitoring strategy defined: cr_errorlog table schema, error Scope pattern, notification configuration
    - ConfidenceCalibration.test.tsx covers all 4 tabs, empty state, division safety, and edge cases
    - index.test.ts covers init, updateView, getOutputs, destroy, and output property reset
    - jest.config.ts no longer excludes index.ts from coverage
  </done>
</task>

</tasks>

<verification>
1. NUDGE data flow: Staleness Monitor (Flow 8) sets discrete column -> useCardData reads via getFormattedValue -> CardItem displays NUDGE status
2. Command flow: Canvas App sends command -> Flow 7 invokes Orchestrator -> response flows back via orchestratorResponse property -> CommandBar displays result
3. Error recovery: Any render crash caught by ErrorBoundary -> user sees "Try Again" button -> dashboard recovers
4. Monitoring: Flow errors logged to cr_errorlog table + admin notification sent
5. Test coverage: ConfidenceCalibration and index.ts have comprehensive test files
6. All tests pass: `cd enterprise-work-assistant/src && npx jest --config test/jest.config.ts`
</verification>

<success_criteria>
- All 8 issues (F-01, F-02, F-03, F-07, I-17, I-18, F-04, F-05) are resolved
- useCardData.ts uses getFormattedValue for card_status (not just JSON blob)
- ControlManifest.Input.xml has orchestratorResponse + isProcessing properties
- ErrorBoundary.tsx exists and is used in App.tsx
- ConfidenceCalibration.test.tsx has 7+ test cases covering all analytics paths
- index.test.ts has 5+ test cases covering PCF lifecycle
- jest.config.ts no longer excludes index.ts from coverage
- Monitoring strategy documented with cr_errorlog table and error Scope pattern
- All existing tests still pass after changes
</success_criteria>

<output>
After completion, create `.planning/phases/13-remediation/13-03-SUMMARY.md`
</output>
